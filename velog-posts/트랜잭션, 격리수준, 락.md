<p>지금까지 했던 소규모 프로젝트에서는 @Transactional 어노테이션으로 동시성을 어느정도 예방하고 해결할 수 있었다. 부하가 커지면 Transactional만으로는 부족하기 때문에 추가적으로 락을 부여해야 한다. </p>
<h3 id="문제-상황">문제 상황</h3>
<blockquote>
<p>만약 수백 명의 사용자가 articleId = 1 인 게시물에 동시에 좋아요롤 눌렀다고 가정하자</p>
</blockquote>
<p>지금까지 내가 사용했던 일반적인 좋아요 코드는 대부분 이러한 양식인데,</p>
<pre><code class="language-like.java">@Transactional
public void like(Long articleId, Long userId) {
    Article article = articleRepository.findById(articleId)
            .orElseThrow(...);

    article.increaseLikeCount(); // likeCount++

    articleRepository.save(article);
}</code></pre>
<p>만약 동시에 좋아요 요청이 들어온다면 
articleId = 1 조회, 둘 다 likeCount가 10인 상태를 읽었다고 가정 -&gt; 두 개의 트랜잭션이 모두 likeCount를 11로 업데이트</p>
<p>실제로는 12가 되어야 하나 카운트가 1만 올라가는 lost update가 발생한다.</p>
<h3 id="트랜잭션-격리-수준">트랜잭션 격리 수준</h3>
<p>여기서 트랜잭션 ACID 개념도 간단하게 알고 넘어가야 한다.
ACID (Atomicity, Consistency, Isolation, Durability) 규칙을 모두 보장해 db의 트랜잭션이 안전하게 수행되어야 하는 것이다. 
그 중에 격리성 (Isolation)에도 레벨이 있고, 각 레벨마다 격리 수준이 다르다.
엄격한 순으로</p>
<ul>
<li>SERIALIZABLE<ul>
<li>트랜잭션을 순차적으로 처리하므로 가장 안전하지만 락 충돌이 많아 성능이 매우 떨어짐</li>
</ul>
</li>
<li>REPEATABLE READ<ul>
<li>같은 트랜잭션 안에서는 같은 행을 다시 읽어도 값이 변하지 않도록 보장</li>
<li>하지만 특수한 경우에선 유령 읽기 (Phantom Read)가 발생할 수 있음 </li>
</ul>
</li>
<li>READ COMMITTED<ul>
<li>다른 트랜잭션이 커밋한 데이터만 읽지만 Phantom read + Non-Repeatable Read (반복 읽기 불가능) 문제 발생 가능</li>
</ul>
</li>
<li>READ UNCOMMITED<ul>
<li>커밋하지 않은 데이터도 접근할 수 있으므로 MySQL을 사용한다면 최소한 READ COMMITTED 이상의 격리 수준을 사용해야 함</li>
</ul>
</li>
</ul>
<p><a href="https://mangkyu.tistory.com/299">해당 블로그</a>에서 더 자세하게 확인할 수 있다! </p>
<p>앞서 얘기했던 문제점 중 이번엔 lost update에 대해 자세히 살펴보도록 하겠다.
그러러면?</p>
<h3 id="lock-전략">Lock 전략</h3>
<p>lock 전략에는 Pessimistic lock, Optimistic lock, update query가 있다.</p>
<p><strong>비관락 (Pessimistic lock)</strong>
말 그대로 비관적으로 접근하는 것. 충돌이 날 것을 예방해 미리 락을 거는 것이다. </p>
<pre><code>// select ... for update 시 락 발생
    @Lock(LockModeType.PESSIMISTIC_WRITE)
    Optional&lt;ArticleLikeCount&gt; findLockedByArticleId(Long articleId);</code></pre><p>충돌 상황에서도 데이터의 정합성을 보장할 수 있으나 대기 시간이 길어나 전체 처리량이 감소할 수 있다.</p>
<p><strong>낙관락(Optimistic Lock, @Version)</strong>
말 그대로 낙관적으로 접근하는 것. 충돌이 일어났을 때만 처리한다.
@Version 어노테이션을 사용해 조회 시점과 업데이트 시점의 버전이 같은지 체크한다.</p>
<pre><code>@Version
    private Long version;</code></pre><p>어려울 것 없이 엔티티에 @Version 어노테이션만 추가하면 된다.</p>
<p>락 경합이 적어 비관적 락에 비해 성능이 우수할 수 있으나 충돌이 발생하면 예외가 터지고 재시도 로직을 직접 구현해야 한다.</p>
<pre><code>ArticleLikeCount articleLikeCount = articleLikeCountRepository.findLockedByArticleId(articleId)
                .orElseGet(() -&gt; ArticleLikeCount.init(articleId, 0L));</code></pre><p>우선은 예외가 터지면 articleId를 0으로 초기화하도록 작성했지만 재시도 로직에 대해선 조금 더 고민해야 될 것 같다.</p>
<p><strong>UPDATE 쿼리 방식</strong>
낙관락을 직접 구현하는 방식이다.</p>
<pre><code>@Query(
            value = &quot;update article_like_count set like_count = like_count + 1 where article_id = :articleId&quot;,
            nativeQuery = true
    )
    @Modifying
    int increase(@Param(&quot;articleId&quot;) Long articleId);</code></pre><p>JPA @Modifying + @Query를 사용해서 구현할 수 있다.
현재 코드로 10,000 요청 / 200 스레드의 테스트로 진행한 결과</p>
<table>
<thead>
<tr>
<th></th>
<th>실행 시간</th>
<th>카운트 수</th>
</tr>
</thead>
<tbody><tr>
<td>비관락 (Pessimistic lock)</td>
<td>29240 ms</td>
<td>10001</td>
</tr>
<tr>
<td>낙관락(Optimistic Lock, @Version)</td>
<td>24623 ms</td>
<td>10001</td>
</tr>
<tr>
<td>UPDATE 쿼리 방식</td>
<td>18075 ms</td>
<td>22844</td>
</tr>
</tbody></table>
<p>좋아요처럼 간단하고 충돌이 적은 서비스에는 낙관적 락이 가장 성능이 좋은 것을 확인할 수 있다. 
update query에서 카운트 수가 많은 이유는 코드 상 여러 스레드가 동시에 호출하면 여러 번 insert가 시도되기 때문이다. 
나중에 서비스 규모가 커지고 부하가 많이 걸렸을 때도 낙관적 락이 가장 성능이 좋을까? </p>
<p>추가적으로 유니크 인덱스랑 샤딩에 대해서도 더 공부해야 할 것 같다ㅎㅎ</p>